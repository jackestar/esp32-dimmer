<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Dimmer Controller</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#050505">
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="./favicon.svg">
</head>
<body>
    <!-- is not a active rectifier but it works -->
    <h1>ESP32 Dimmer</h1>
    <button id="connectBtn" onclick="connectToDevice()">Connect to ESP32</button>
    <p id="status">Status: Disconnected</p>

    <div class="circle-wrap" id="sliderWrap">
        <svg id="sliderSVG" viewBox="0 0 200 200">
            <defs>
                <linearGradient id="g1" x1="0%" x2="100%" y1="0%" y2="0%">
                    <stop offset="0%" stop-color="#ff7a18" />
                    <stop offset="100%" stop-color="#af002d" />
                </linearGradient>
            </defs>
            <circle cx="100" cy="100" r="72" fill="none" stroke="#eee" stroke-width="14" />
            <circle id="progress" cx="100" cy="100" r="72" fill="none" stroke="url(#g1)" stroke-width="14" stroke-linecap="round" transform="rotate(-90 100 100)" stroke-dasharray="452" stroke-dashoffset="452" />
            <circle id="knob" cx="100" cy="28" r="8" fill="#333" stroke="#fff" stroke-width="2" cursor="pointer" />
        </svg>
        <div id="powerLabel">0 %</div>
        <div id="centerToggle" class="center-btn">OFF</div>
    </div>

    <div id="controls">
        <button id="decBtn" class="small-btn" onclick="sendPower(Math.max(0, currentPower-5))" disabled>-5%</button>
        <button id="fullBtn" class="small-btn" onclick="sendPower(100)" disabled>100%</button>
        <button id="incBtn" class="small-btn" onclick="sendPower(Math.min(100, currentPower+5))" disabled>+5%</button>
    </div>

    <div id="biasControl" class="bias-control">
        <label for="biasRange">Bias: <span id="biasLabel">0%</span></label>
        <input id="biasRange" type="range" min="0" max="100" value="17" />
    </div>

    <script>
        // Use UUIDs that match the ESP32 firmware
        const serviceUUID = '4fafc201-1fb5-459e-8fcc-c5c9c331914b';
        const charUUID = 'beb5483e-36e1-4688-b7f5-ea07361b26a8';
        

        let device;
        let characteristic;
        let currentPower = 0;
        let currentBias = 0;
        let lastNonZero = 50;

        // SVG elements
        const svg = document.getElementById('sliderSVG');
        const progress = document.getElementById('progress');
        const knob = document.getElementById('knob');
        const label = document.getElementById('powerLabel');
        const biasRange = document.getElementById('biasRange');
        const biasLabel = document.getElementById('biasLabel');
        const centerToggle = document.getElementById('centerToggle');
        const container = document.getElementById('sliderWrap');

        const R = 72; // radius in svg coords
        const C = 100; // center
        const CIRC = 2 * Math.PI * R; // circumference
        progress.style.strokeDasharray = `${CIRC}`;
        // smooth transition like slider.html
        progress.style.transition = 'stroke-dashoffset 0.08s linear';

        function pctToOffset(p) {
            return CIRC * (1 - p / 100);
        }

        function setUI(p) {
            if (p < 0) p = 0; if (p > 100) p = 100;
            currentPower = Math.round(p);
            label.innerText = `${currentPower} %`;
            progress.style.strokeDashoffset = pctToOffset(currentPower);
            // position knob
            const angle = (currentPower / 100) * 360 - 90; // start at top
            const rad = angle * Math.PI / 180;
            const x = C + R * Math.cos(rad);
            const y = C + R * Math.sin(rad);
            knob.setAttribute('cx', x);
            knob.setAttribute('cy', y);
            centerToggle.innerText = currentPower === 0 ? 'OFF' : 'ON';
        }

        function setBiasUI(b) {
            if (b < 0) b = 0; if (b > 100) b = 100;
            currentBias = Math.round(b);
            biasLabel.innerText = `${currentBias} %`;
            if (biasRange) biasRange.value = currentBias;
        }

        function pointToPercent(x, y) {
            const dx = x - C;
            const dy = y - C;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI + 90; // 0 at top
            if (angle < 0) angle += 360;
            const p = (angle / 360) * 100;
            return p;
        }

        // Drag handling (mouse + touch) modeled after slider.html for smooth experience
        let isDragging = false;
        let lastSendTime = 0;
        const SEND_THROTTLE_MS = 80; // send at most every 80ms while dragging

        function getAngle(event) {
            const rect = container.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            const x = clientX - rect.left - rect.width / 2;
            const y = clientY - rect.top - rect.height / 2;
            let angle = Math.atan2(y, x) * (180 / Math.PI) + 90;
            if (angle < 0) angle += 360;
            return angle;
        }

        function handleInteraction(event) {
            event.preventDefault();
            const angle = getAngle(event);
            const value = (angle / 360) * 100;
            setUI(value);

            // Throttle BLE writes while dragging for real-time feel without flooding
                if (characteristic) {
                    const now = Date.now();
                    if (now - lastSendTime >= SEND_THROTTLE_MS) {
                        // fire-and-forget write (send power + bias)
                        characteristic.writeValue(new Uint8Array([currentPower, currentBias])).catch((e) => {
                            console.warn('Throttled write failed', e);
                        });
                        lastSendTime = now;
                    }
                }
        }

        // Prevent slider interaction when clicking the center button
        centerToggle.addEventListener('mousedown', (e) => e.stopPropagation());
        centerToggle.addEventListener('touchstart', (e) => e.stopPropagation());

        container.addEventListener('mousedown', (e) => { isDragging = true; handleInteraction(e); });
        container.addEventListener('touchstart', (e) => { isDragging = true; handleInteraction(e); });

        document.addEventListener('mousemove', (e) => { if (isDragging) handleInteraction(e); });
        document.addEventListener('touchmove', (e) => { if (isDragging) handleInteraction(e); });

        function stopDragAndSend(e) {
            if (!isDragging) return;
            isDragging = false;
            sendPower(currentPower);
        }

        document.addEventListener('mouseup', stopDragAndSend);
        document.addEventListener('touchend', stopDragAndSend);

        // Center toggle
        // Prevent slider dragging when interacting with center button
        centerToggle.addEventListener('pointerdown', (e) => e.stopPropagation());
        centerToggle.addEventListener('mousedown', (e) => e.stopPropagation());
        centerToggle.addEventListener('touchstart', (e) => e.stopPropagation());

        centerToggle.addEventListener('click', () => {
            if (currentPower === 0) {
                // restore
                sendPower(lastNonZero || 50);
            } else {
                lastNonZero = currentPower;
                sendPower(0);
            }
        });

        // BLE connect/send
        async function connectToDevice() {
            try {
                document.getElementById('status').innerText = "Status: Scanning...";
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'ESP32_DIMMER' }],
                    optionalServices: [serviceUUID]
                });
                document.getElementById('status').innerText = "Status: Connecting...";
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(serviceUUID);
                characteristic = await service.getCharacteristic(charUUID);
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('status').innerText = "Status: Connected!";
                document.getElementById('incBtn').disabled = false;
                document.getElementById('decBtn').disabled = false;
                document.getElementById('fullBtn').disabled = false;
                device.addEventListener('gattserverdisconnected', onDisconnected);
                window.addEventListener('wheel', onWheel);

                // Subscribe to notifications from the characteristic
                try {
                    await characteristic.startNotifications();
                    characteristic.addEventListener('characteristicvaluechanged', onNotification);
                } catch (err) {
                    console.warn('Notifications not available', err);
                }
                // Indicate connected state on the Connect button
                const connectBtn = document.getElementById('connectBtn');
                connectBtn.disabled = true;
                connectBtn.classList.add('connected');
                connectBtn.innerText = 'Connected';
                // wire bias control to update bias and send combined payload
                if (biasRange) {
                    // Update UI while dragging and send throttled writes so bias takes effect live
                    biasRange.addEventListener('input', (e) => {
                        setBiasUI(e.target.value);
                        // Throttled live write of bias with current power
                        if (characteristic) {
                            const now = Date.now();
                            if (now - lastSendTime >= SEND_THROTTLE_MS) {
                                characteristic.writeValue(new Uint8Array([currentPower, currentBias])).catch((err) => console.warn('Bias live write failed', err));
                                lastSendTime = now;
                            }
                        }
                    });
                    // Commit on change/end to ensure final value is sent
                    biasRange.addEventListener('change', (e) => {
                        sendPower(currentPower);
                    });
                }
            } catch (error) {
                console.error(error);
                document.getElementById('status').innerText = "Status: Error - " + error;
            }
        }

        async function sendPower(p) {
            if (!characteristic) return;
            if (p < 0) p = 0; if (p > 100) p = 100;
            setUI(p);
            try {
                await characteristic.writeValue(new Uint8Array([currentPower, currentBias]));
            } catch (error) {
                console.error('Write failed', error);
                document.getElementById('status').innerText = 'Status: Write Failed';
            }
        }

        // Notification handler: update UI when device reports value
        function onNotification(event) {
            const data = event.target.value;
            if (!data || data.byteLength < 1) return;
            const v = data.getUint8(0);
            setUI(v);
            if (data.byteLength > 1) {
                const b = data.getUint8(1);
                setBiasUI(b);
            }
        }

        async function onDisconnected(event) {
            document.getElementById('status').innerText = "Status: Disconnected";
            const connectBtn = document.getElementById('connectBtn');
            connectBtn.disabled = false;
            connectBtn.classList.remove('connected');
            connectBtn.innerText = 'Connect to ESP32';
            document.getElementById('incBtn').disabled = true;
            document.getElementById('decBtn').disabled = true;
            document.getElementById('fullBtn').disabled = true;
            window.removeEventListener('wheel', onWheel);
            // Unsubscribe notifications
            try {
                if (characteristic) {
                    characteristic.removeEventListener('characteristicvaluechanged', onNotification);
                    await characteristic.stopNotifications();
                }
            } catch (err) {
                console.warn('Failed to stop notifications', err);
            }
        }

        function onWheel(e) {
            const step = 1;
            if (e.deltaY < 0) sendPower(currentPower + step);
            else sendPower(currentPower - step);
        }

        // init UI
        setUI(0);
        setBiasUI(0);

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(() => {
                console.log('Service Worker registered');
            }).catch((err) => console.warn('SW registration failed', err));
        }
    </script>
</body>
</html>